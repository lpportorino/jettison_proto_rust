// This file is @generated by prost-build.
/// Request message for video metadata retrieval
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VideoMetaRequest {
    #[prost(oneof = "video_meta_request::Query", tags = "1, 2")]
    pub query: ::core::option::Option<video_meta_request::Query>,
}
/// Nested message and enum types in `VideoMetaRequest`.
pub mod video_meta_request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Query {
        /// Time-based range query
        #[prost(message, tag = "1")]
        Range(super::VideoRangeQuery),
        /// Explicit UUID list
        #[prost(message, tag = "2")]
        Ids(super::VideoIdList),
    }
}
/// List of video UUIDs for explicit selection
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VideoIdList {
    #[prost(string, repeated, tag = "1")]
    pub uuids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Time-based range query for selecting videos
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VideoRangeQuery {
    /// Unix seconds
    #[prost(uint64, tag = "1")]
    pub start_timestamp: u64,
    /// Unix seconds
    #[prost(uint64, tag = "2")]
    pub end_timestamp: u64,
    /// "day" or "heat" filter
    #[prost(string, optional, tag = "3")]
    pub source_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "4")]
    pub limit: ::core::option::Option<u32>,
    /// Pagination offset
    #[prost(uint32, optional, tag = "5")]
    pub offset: ::core::option::Option<u32>,
}
/// Response containing video metadata and any errors
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VideoMetaResponse {
    /// Successfully processed videos
    #[prost(message, repeated, tag = "1")]
    pub videos: ::prost::alloc::vec::Vec<VideoMeta>,
    /// Errors for failed videos
    #[prost(message, repeated, tag = "2")]
    pub errors: ::prost::alloc::vec::Vec<VideoError>,
    /// Total matching (before limit)
    #[prost(uint32, tag = "3")]
    pub total_count: u32,
    /// Shared encoding parameters (same for all videos in response)
    ///
    /// 1920 for full, 480 for mini
    #[prost(uint32, tag = "10")]
    pub width: u32,
    /// 1080 for full, 270 for mini
    #[prost(uint32, tag = "11")]
    pub height: u32,
    /// avcC decoder specific info (shared codec config)
    #[prost(bytes = "vec", tag = "12")]
    pub dsi: ::prost::alloc::vec::Vec<u8>,
    /// Media timescale from mdhd
    #[prost(uint32, tag = "13")]
    pub timescale: u32,
}
/// Metadata for a single video including MOOV data
/// Used by both /api/video/meta (full quality) and /api/video/meta-mini (preview quality)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VideoMeta {
    #[prost(string, tag = "1")]
    pub uuid: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub session_id: i32,
    /// Unix seconds
    #[prost(uint64, tag = "3")]
    pub timestamp: u64,
    /// Directory path to video files
    #[prost(string, tag = "4")]
    pub storage_path: ::prost::alloc::string::String,
    /// "day" or "heat"
    #[prost(string, tag = "5")]
    pub source_type: ::prost::alloc::string::String,
    /// Per-video MOOV data
    #[prost(uint32, tag = "6")]
    pub frame_count: u32,
    #[prost(uint32, tag = "7")]
    pub duration_ms: u32,
    /// Sample table for frame-accurate seeking and playback
    #[prost(message, optional, tag = "12")]
    pub sample_table: ::core::option::Option<SampleTable>,
}
/// MP4 sample table data extracted from MOOV
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SampleTable {
    /// Frame sizes in bytes (stsz)
    #[prost(uint32, repeated, tag = "1")]
    pub sample_sizes: ::prost::alloc::vec::Vec<u32>,
    /// Byte offsets in file (stco/co64)
    #[prost(uint64, repeated, tag = "2")]
    pub chunk_offsets: ::prost::alloc::vec::Vec<u64>,
    /// Decoding timestamps (stts deltas)
    #[prost(uint32, repeated, tag = "3")]
    pub sample_times: ::prost::alloc::vec::Vec<u32>,
    /// Keyframe indices, 1-based (stss)
    #[prost(uint32, repeated, tag = "4")]
    pub sync_samples: ::prost::alloc::vec::Vec<u32>,
    /// Sample-to-chunk mapping (stsc)
    #[prost(message, repeated, tag = "5")]
    pub sample_to_chunk: ::prost::alloc::vec::Vec<SampleToChunk>,
}
/// Sample-to-chunk box entry
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SampleToChunk {
    #[prost(uint32, tag = "1")]
    pub first_chunk: u32,
    #[prost(uint32, tag = "2")]
    pub samples_per_chunk: u32,
    #[prost(uint32, tag = "3")]
    pub sample_description_index: u32,
}
/// Error information for a video that failed processing
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VideoError {
    #[prost(string, tag = "1")]
    pub uuid: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub storage_path: ::prost::alloc::string::String,
    #[prost(enumeration = "VideoErrorType", tag = "3")]
    pub error_type: i32,
    #[prost(string, tag = "4")]
    pub error_message: ::prost::alloc::string::String,
}
/// Types of errors that can occur during video metadata extraction
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VideoErrorType {
    Unspecified = 0,
    FileNotFound = 1,
    EmptyFile = 2,
    NoMoov = 3,
    InvalidMoov = 4,
    Truncated = 5,
}
impl VideoErrorType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "VIDEO_ERROR_TYPE_UNSPECIFIED",
            Self::FileNotFound => "VIDEO_ERROR_TYPE_FILE_NOT_FOUND",
            Self::EmptyFile => "VIDEO_ERROR_TYPE_EMPTY_FILE",
            Self::NoMoov => "VIDEO_ERROR_TYPE_NO_MOOV",
            Self::InvalidMoov => "VIDEO_ERROR_TYPE_INVALID_MOOV",
            Self::Truncated => "VIDEO_ERROR_TYPE_TRUNCATED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VIDEO_ERROR_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "VIDEO_ERROR_TYPE_FILE_NOT_FOUND" => Some(Self::FileNotFound),
            "VIDEO_ERROR_TYPE_EMPTY_FILE" => Some(Self::EmptyFile),
            "VIDEO_ERROR_TYPE_NO_MOOV" => Some(Self::NoMoov),
            "VIDEO_ERROR_TYPE_INVALID_MOOV" => Some(Self::InvalidMoov),
            "VIDEO_ERROR_TYPE_TRUNCATED" => Some(Self::Truncated),
            _ => None,
        }
    }
}
